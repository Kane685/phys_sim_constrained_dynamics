#include "basic/include/log.hpp"

namespace phys_sim_constrained_dynamics {

static const std::string RedHead() {
    return "\x1b[6;30;91m";
}

static const std::string RedTail() {
    return "\x1b[0m";
}

static const std::string YellowHead() {
    return "\x1b[6;30;93m";
}

static const std::string YellowTail() {
    return "\x1b[0m";
}

static const std::string GreenHead() {
    return "\x1b[6;30;92m";
}

static const std::string GreenTail() {
    return "\x1b[0m";
}

static const std::string CyanHead() {
    return "\x1b[6;30;96m";
}

static const std::string CyanTail() {
    return "\x1b[0m";
}

void PrintInfo(const std::string& location, const std::string& message) {
    std::cout << CyanHead() << "[" << location << "]: " << message << CyanTail()
        << std::endl;
}

void PrintWarning(const std::string& location, const std::string& message) {
    std::cout << YellowHead() << "[" << location << "]: " << message
        << YellowTail() << std::endl;
}

void PrintError(const std::string& location, const std::string& message) {
    std::stringstream ss;
    ss << RedHead() << "[" << location << "]: " << message << RedTail()
        << std::endl;
    std::cerr << ss.str();
    throw std::runtime_error(ss.str());
}

void PrintSuccess(const std::string& location, const std::string& message) {
    std::cout << GreenHead() << "[" << location << "]: " << message
        << GreenTail() << std::endl;
}

void CheckCondition(const bool condition, const std::string& location,
    const std::string& message) {
    if (!condition) {
        PrintError(location, message);
    }
}

const bool StartWith(const std::string& full, const std::string& prefix) {
    if (full.size() < prefix.size()) return false;
    return std::equal(prefix.begin(), prefix.end(), full.begin());
}

const bool EndWith(const std::string& full, const std::string& suffix) {
    if (full.size() < suffix.size()) return false;
    return std::equal(suffix.rbegin(), suffix.rend(), full.rbegin());
}

// Timing.
static std::stack<timeval> t_begins;

void Tic() {
    timeval t_begin;
    gettimeofday(&t_begin, nullptr);
    t_begins.push(t_begin);
}

void Toc(const std::string& location, const std::string& message) {
    timeval t_end;
    gettimeofday(&t_end, nullptr);
    timeval t_begin = t_begins.top();
    const real t_interval = (t_end.tv_sec - t_begin.tv_sec)
        + (t_end.tv_usec - t_begin.tv_usec) / 1e6;
    std::cout << "[" << location << "]: (" << t_interval << "s) " << message
        << std::endl;
    t_begins.pop();
}

const real Toc() {
    timeval t_end;
    gettimeofday(&t_end, nullptr);
    timeval t_begin = t_begins.top();
    const real t_interval = (t_end.tv_sec - t_begin.tv_sec)
        + (t_end.tv_usec - t_begin.tv_usec) / 1e6;
    t_begins.pop();

    return t_interval;
}

template<>
void Save<integer>(std::ofstream& f, const integer& val) {
    const int64_t val_cast = static_cast<int64_t>(val);
    f.write(reinterpret_cast<const char*>(&val_cast), sizeof(int64_t));
}

template<>
void Save<real>(std::ofstream& f, const real& val) {
    const double val_cast = static_cast<double>(val);
    f.write(reinterpret_cast<const char*>(&val_cast), sizeof(double));
}

template<>
const integer Load<integer>(std::ifstream& f) {
    int64_t val = 0;
    f.read(reinterpret_cast<char*>(&val), sizeof(int64_t));
    return static_cast<integer>(val);
}

template<>
const real Load<real>(std::ifstream& f) {
    double val = 0;
    f.read(reinterpret_cast<char*>(&val), sizeof(double));
    return static_cast<real>(val);
}

void SaveVectorXr(const std::string& file_name, const VectorXr& vec) {
    std::ofstream f(file_name);
    const integer num = static_cast<integer>(vec.size());
    Save<integer>(f, num);
    for (integer i = 0; i < num; ++i) {
        Save<real>(f, vec(i));
    }
}

const VectorXr LoadVectorXr(const std::string& file_name) {
    std::ifstream f(file_name);
    const integer num = Load<integer>(f);
    VectorXr vec = VectorXr::Zero(num);
    for (integer i = 0; i < num; ++i) {
        vec(i) = Load<real>(f);
    }
    return vec;
}

const std::pair<Matrix3Xr, Matrix3Xi> LoadObjMesh(
    const std::string& file_name) {

    std::ifstream file(file_name);
    std::vector<Vector3r> vertices_data;
    std::vector<Vector3i> elements_data;

    std::string line;
    integer vertex_num = 0;
    integer element_num = 0;
    while (std::getline(file, line)) {
        // We refer to a simple obj generated by meshlab which consists of only
        // three things:
        // - Comments: it begins with #.
        // - Vertices: it begins with v followed by three floats.
        // - Triangles: it begins with f followed by three ints.
        // No normals or textures.
        if (line[0] == '#') {
            continue;
        } else if (line[0] == 'v') {
            std::stringstream ss(line.substr(2));
            Vector3r vertex;
            ss >> vertex.x() >> vertex.y() >> vertex.z();
            vertices_data.push_back(vertex);
            ++vertex_num;
        } else if (line[0] == 'f') {
            std::stringstream ss(line.substr(2));
            Vector3i element;
            ss >> element.x() >> element.y() >> element.z();
            // Obj vertex indices begin at 1 instead of 0.
            elements_data.push_back(element.array() - 1);
            ++element_num;
        }
    }
    CheckCondition(vertex_num >= 3 && element_num > 0, "basic::LoadObjMesh",
        "Failed to load obj.");
    Matrix3Xr vertices(3, vertex_num);
    for (integer i = 0; i < vertex_num; ++i)
        vertices.col(i) = vertices_data[i];
    Matrix3Xi elements(3, element_num);
    for (integer i = 0; i < element_num; ++i)
        elements.col(i) = elements_data[i];

    return { vertices, elements };
}

}